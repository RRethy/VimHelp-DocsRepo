<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">
  </head>
  <body>
                <img src="images/logo@2x.png" id="navbar-logo" alt="Neovim">

    <div class="container">
      <h1>Nvim documentation: ui</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>
*<A NAME="ui.txt"></A><B>ui.txt</B>*	Nvim


			    NVIM REFERENCE MANUAL



Nvim UI protocol							  *<A NAME="ui"></A><B>ui</B>*

                                      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

UI Events							    *<A NAME="ui-events"></A><B>ui-events</B>*

GUIs can be implemented <A HREF="motion.html#as">as</A> external processes communicating with Nvim over the
<A HREF="msgpack_rpc.html#RPC">RPC</A> <A HREF="api.html#API">API</A>. The UI model consists of a terminal-like grid with a single,
monospace font size. Some elements (UI &quot;widgets&quot;) can be drawn separately from
the grid (&quot;externalized&quot;).



								  *<A NAME="ui-options"></A><B>ui-options</B>*
The |<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>| <A HREF="api.html#API">API</A> method is used to tell Nvim that your program wants to
draw the Nvim screen grid with a size of width Ã— height cells. This is typically
done by an embedder, see |<A HREF="#ui-startup">ui-startup</A>| below for details, but an UI can also
connect to a running <A HREF="nvim.html#nvim">nvim</A> instance and invoke this method. `options` must be
a dictionary with these (optional) keys:

	`rgb`			Decides the color format. *<A NAME="ui-rgb"></A><B>ui-rgb</B>*
				Set true (default) for 24-bit RGB colors.
				Set false for <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> colors (max of 256).

							      *<A NAME="ui-ext-options"></A><B>ui-ext-options</B>*
	`ext_popupmenu`		Externalize the popupmenu. |<A HREF="#ui-popupmenu">ui-popupmenu</A>|
	`ext_tabline`		Externalize the tabline. |<A HREF="#ui-tabline">ui-tabline</A>|
	`ext_cmdline`		Externalize the cmdline. |<A HREF="#ui-cmdline">ui-cmdline</A>|
	`ext_wildmenu`		Externalize the wildmenu. |<A HREF="#ui-wildmenu">ui-wildmenu</A>|
	`ext_linegrid`		Use new revision of the grid events. |<A HREF="#ui-linegrid">ui-linegrid</A>|
	`ext_hlstate`		Use detailed highlight state. |<A HREF="#ui-hlstate">ui-hlstate</A>|

Specifying a non-existent option is an error. UIs can check the |<A HREF="api.html#api-metadata">api-metadata</A>|
`ui_options` key for supported <A HREF="options.html#options">options</A>. Additionally Nvim (currently) requires
that all connected UIs use the same set of widgets. Therefore the active
widgets will be the intersection of the requested widget sets of all connected
UIs. The &quot;option_set&quot; event announces which widgets actually are active.

Nvim sends <A HREF="msgpack_rpc.html#msgpack-rpc">msgpack-rpc</A> notifications to all attached UIs, with method name
&quot;redraw&quot; and a single argument: an array (batch) of screen &quot;update events&quot;.
Each update event is itself an array whose first element is the event name and
remaining elements are event-parameter tuples. This allows multiple events of
the same kind to be sent in a row without the event name being repeated. This
batching is mostly used for &quot;grid_line&quot;, because each &quot;grid_line&quot; event puts
contents in one screen line, but clients must be prepared for multiple argument
sets being batched for all event kinds.

Events must be handled in-order. A &quot;flush&quot; event is sent when <A HREF="nvim.html#nvim">nvim</A> is done
redrawing the entire screen (so that all <A HREF="windows.html#windows">windows</A> have a consistent view of
buffer state, <A HREF="options.html#options">options</A> etc). Clients should be prepared that several &quot;redraw&quot;
batches are sent before the entire screen has been redrawn, and only the last
batch will end in &quot;flush&quot;. The user should only see the final state when
&quot;flush&quot; is sent, and not any intermediate state after processing only part of
the batch array, nor after a batch not ending with &quot;flush&quot;.

By default, Nvim sends |<A HREF="#ui-global">ui-global</A>| and |<A HREF="#ui-grid-old">ui-grid-old</A>| events; these suffice to
implement a terminal-like interface. However there are two revisions of the
grid part of the protocol. The newer revision |<A HREF="#ui-linegrid">ui-linegrid</A>|, enabled by
`ext_linegrid` option, has a more effecient representation of text (especially
highlighted text), and room for futher enhancements that will use
multiple grids. The older revision is available and used by default only for
backwards compatibility reasons. New UIs are strongly recommended to use
|<A HREF="#ui-linegrid">ui-linegrid</A>|, <A HREF="motion.html#as">as</A> further protocol extensions will require <A HREF="motion.html#it">it</A>.

Nvim optionally sends screen elements &quot;semantically&quot; <A HREF="motion.html#as">as</A> structured events
instead of raw grid-lines, controlled by |<A HREF="#ui-ext-options">ui-ext-options</A>|. The UI must present
those elements itself; Nvim will not draw those elements on the grid.

Future versions of Nvim may add new update kinds and may append new parameters
to existing update kinds. Clients must be prepared to ignore such extensions,
for forward-compatibility. |<A HREF="api.html#api-contract">api-contract</A>|

==============================================================================

UI <A HREF="starting.html#startup">startup</A>							   *<A NAME="ui-startup"></A><B>ui-startup</B>*

Nvim defines a standard procedure for how an embedding UI should interact with
the <A HREF="starting.html#startup">startup</A> phase of Nvim. When spawning the <A HREF="nvim.html#nvim">nvim</A> process, use the |<A HREF="starting.html#--embed">--embed</A>| flag
but not the |<A HREF="starting.html#--headless">--headless</A>| flag. The started Nvim process will pause before loading
<A HREF="starting.html#startup">startup</A> files and reading <A HREF="windows.html#buffers">buffers</A>, and give the UI a chance to invoke requests
to <A HREF="diff.html#do">do</A> early <A HREF="starting.html#initialization">initialization</A>. As soon <A HREF="motion.html#as">as</A> the UI invokes |<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>|, the
<A HREF="starting.html#startup">startup</A> will continue.

A simple UI only need to <A HREF="diff.html#do">do</A> a single |<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>| request and then
be prepared to handle any UI event. A more featureful UI, which might need
additional configuration of the <A HREF="nvim.html#nvim">nvim</A> process, should use the following <A HREF="starting.html#startup">startup</A>
procedure:

1. Invoke |<A HREF="api.html#nvim_get_api_info()">nvim_get_api_info()</A>|, if this is needed to setup the client library
   and/or to get the <A HREF="eval.html#list">list</A> of supported UI extensions.
2. At this time, any configuration that should be happen before <A HREF="starting.html#init.vim">init.vim</A>
   loading should be done. Buffers and <A HREF="windows.html#windows">windows</A> are not available at this
   point, but this could be used to set |<A HREF="eval.html#g:">g:</A>| <A HREF="eval.html#variables">variables</A> visible to <A HREF="starting.html#init.vim">init.vim</A>
3. If the UI wants to <A HREF="diff.html#do">do</A> additional setup after the <A HREF="starting.html#init.vim">init.vim</A> file was loaded
   <A HREF="sponsor.html#register">register</A> an <A HREF="autocmd.html#autocmd">autocmd</A> for <A HREF="autocmd.html#VimEnter">VimEnter</A> at this point:

<B>    nvim_command("autocmd VimEnter * call rpcrequest(1, 'vimenter')")</B>

 4.  Now invoke |<A HREF="api.html#nvim_ui_attach()">nvim_ui_attach()</A>|. The UI will need to handle keyboard input
    at this point, <A HREF="motion.html#as">as</A> sourcing <A HREF="starting.html#init.vim">init.vim</A> and loading <A HREF="windows.html#buffers">buffers</A> might lead to
    blocking prompts.
5.  If step 3 was used, <A HREF="nvim.html#nvim">nvim</A> will send a blocking &quot;vimenter&quot; request to the
    UI. Inside this request handler, the UI can safely <A HREF="diff.html#do">do</A> any <A HREF="starting.html#initialization">initialization</A>
    before entering normal mode, for instance reading <A HREF="eval.html#variables">variables</A> set by
    <A HREF="starting.html#init.vim">init.vim</A>.

==============================================================================

Global Events							    *<A NAME="ui-global"></A><B>ui-global</B>*

The following events will always be available, and describe global state of
the editor.

[&quot;set_title&quot;, title]
[&quot;set_icon&quot;, icon]
	Set the <A HREF="windows.html#window">window</A> title, and icon (minimized) <A HREF="windows.html#window">window</A> title, respectively.
	In windowing systems not distinguishing between the two, &quot;set_icon&quot;
	can be ignored.

[&quot;mode_info_set&quot;, cursor_style_enabled, mode_info]
	`cursor_style_enabled` is a <A HREF="options.html#boolean">boolean</A> indicating if the UI should set
	the cursor style. `mode_info` is a <A HREF="eval.html#list">list</A> of mode property maps. The
	current mode is given by the `mode_idx` field of the `mode_change`
	event.

	Each mode property map may contain these keys:

<B><FONT color="#54A23D">	KEY		DESCRIPTION </FONT></B>
	`cursor_shape`:	&quot;block&quot;, &quot;horizontal&quot;, &quot;vertical&quot;
	`cell_percentage`: Cell <A HREF="motion.html#&#37;">&#37;</A> occupied by the cursor.
	`blinkwait`, `blinkon`, `blinkoff`: See |<A HREF="options.html#cursor-blinking">cursor-blinking</A>|.
	`attr_id`:	Cursor attribute id (defined by `hl_attr_define`)
	`attr_id_lm`:	Cursor attribute id for when <A HREF="options.html#'langmap'">'langmap'</A> is active.
	`short_name`:	Mode code name, see <A HREF="options.html#'guicursor'">'guicursor'</A>.
	`name`:		Mode descriptive name.
	`mouse_shape`:	(To be implemented.)

	Some keys are missing in some modes.
	
	The following keys are <A HREF="deprecated.html#deprecated">deprecated</A>:

	`hl_id`:	Use `attr_id` instead.
	`hl_lm`:	Use `attr_id_lm` instead.

[&quot;option_set&quot;, name, value]
	UI-related option changed, where `name` is one of:

	<A HREF="options.html#'arabicshape'">'arabicshape'</A>
	<A HREF="options.html#'ambiwidth'">'ambiwidth'</A>
	<A HREF="options.html#'emoji'">'emoji'</A>
	<A HREF="options.html#'guifont'">'guifont'</A>
	<A HREF="options.html#'guifontset'">'guifontset'</A>
	<A HREF="options.html#'guifontwide'">'guifontwide'</A>
	<A HREF="options.html#'linespace'">'linespace'</A>
	<A HREF="options.html#'showtabline'">'showtabline'</A>
	<A HREF="options.html#'termguicolors'">'termguicolors'</A>
	&quot;ext_*&quot; (all |<A HREF="#ui-ext-options">ui-ext-options</A>|)

	Triggered when the UI first connects to Nvim, and whenever an option
	is changed by the user or a <A HREF="usr_05.html#plugin">plugin</A>.

	Options are not represented here if their effects are communicated in
	other UI events. For example, instead of forwarding the <A HREF="options.html#'mouse'">'mouse'</A> option
	value, the &quot;mouse_on&quot; and &quot;mouse_off&quot; UI events directly indicate if
	mouse support is active. Some <A HREF="options.html#options">options</A> like <A HREF="options.html#'ambiwidth'">'ambiwidth'</A> have already
	taken effect on the grid, where appropriate empty cells are added,
	however a UI might still use such <A HREF="options.html#options">options</A> when rendering raw text
	sent from Nvim, like for |<A HREF="intro.html#ui-ext-cmdline">ui-ext-cmdline</A>|.

[&quot;mode_change&quot;, mode, mode_idx]
	The mode changed.  The first parameter `mode` is a <A HREF="eval.html#string">string</A> representing
	the current mode. `mode_idx` is an index into the array received in
	the `mode_info_set` event. UIs should change the cursor style
	according to the properties specified in the corresponding item. The
	set of modes reported will change in new versions of Nvim, for
	instance more submodes and temporary states might be represented <A HREF="motion.html#as">as</A>
	separate modes.

[&quot;mouse_on&quot;]
[&quot;mouse_off&quot;]
	Tells the client whether mouse support, <A HREF="motion.html#as">as</A> determined by |<A HREF="options.html#'mouse'">'mouse'</A>|
	option, is considered to be active in the current mode. This is mostly
	useful for a <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> frontend, or other situations where <A HREF="nvim.html#nvim">nvim</A> mouse
	would conflict with other usages of the mouse. It is safe for a client
	to ignore this and always send mouse events.

[&quot;busy_start&quot;]
[&quot;busy_stop&quot;]
	Nvim started or stopped being busy, and possibly not responsive to
	user input. This could be indicated to the user by hiding the cursor.

[&quot;suspend&quot;]
	|<A HREF="starting.html#:suspend">:suspend</A>| command or |<A HREF="starting.html#CTRL-Z">CTRL-Z</A>| <A HREF="map.html#mapping">mapping</A> is used. A <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> client (or
	another client where <A HREF="motion.html#it">it</A> makes sense) could <A HREF="starting.html#suspend">suspend</A> itself.  Other
	clients can safely ignore <A HREF="motion.html#it">it</A>.

[&quot;update_menu&quot;]
	The menu mappings changed.

[&quot;bell&quot;]
[&quot;visual_bell&quot;]
	Notify the user with an audible or visual bell, respectively.

[&quot;flush&quot;]
	Nvim is done redrawing the screen. For an implementation that renders
	to an internal buffer, this is the time to display the redrawn parts
	to the user.

==============================================================================

Grid Events (line-based)					  *<A NAME="ui-linegrid"></A><B>ui-linegrid</B>*

These events are used if `ext_linegrid` option is set (recommended for all new
UIs). The biggest change compared to previous revision is to use a single
event `grid_line` to update the contents of a screen line (where the old
protocol used a combination of cursor, highlight and text events)

Most of these events take a `grid` index <A HREF="motion.html#as">as</A> first parameter.  Grid 1 is the
global grid used by default for the entire editor screen state. Grids other
than that will be defined by future extensions. Just activating the
`ext_linegrid` option by itself will never cause any additional grids to be
created.

Highlight attribute groups are predefined. UIs should maintain a table to map
numerical highlight `id`:s to the actual attributes.

[&quot;grid_resize&quot;, grid, width, height]
	Resize a `grid`. If `grid` wasn't seen by the client before, a new grid is
	being created with this size.

[&quot;default_colors_set&quot;, rgb_fg, rgb_bg, rgb_sp, cterm_fg, cterm_bg]
	The first three arguments set the default foreground, background and
	special colors respectively. `cterm_fg` and `cterm_bg` specifies the
	default color codes to use in a 256-color <A HREF="nvim_terminal_emulator.html#terminal">terminal</A>.

	Note: unlike the corresponding events in the first revision, the
	screen is not always cleared after sending this event. The <A HREF="gui.html#GUI">GUI</A> has to
	repaint the screen with changed background color itself.


							*<A NAME="ui-event-hl_attr_define"></A><B>ui-event-hl_attr_define</B>*
[&quot;hl_attr_define&quot;, id, rgb_attr, cterm_attr, info]
	Add a highlight with `id`  to the highlight table, with the
	attributes specified by the `rgb_attr` and `cterm_attr` dicts, with the
	following (all optional) keys.

	`foreground`:	foreground color.
	`background`:	background color.
	`special`:	color to use for <A HREF="syntax.html#underline">underline</A> and <A HREF="syntax.html#undercurl">undercurl</A>, when present.
	`reverse`:	reverse video. Foreground and background colors are
			switched.
	`italic`:	<A HREF="syntax.html#italic">italic</A> text.
	`bold`:		<A HREF="syntax.html#bold">bold</A> text.
	`underline`:	underlined text. The line has `special` color.
	`undercurl`:	undercurled text. The curl has `special` color.

	For absent color keys the default color should be used. Don't store
	the default value in the table, rather a sentinel value, so that
	a changed default color will take effect.
	All <A HREF="options.html#boolean">boolean</A> keys default to false, and will only be sent when they
	are true.

	Highlights are always transmitted both for both the rgb format and <A HREF="motion.html#as">as</A>
	<A HREF="nvim_terminal_emulator.html#terminal">terminal</A> 256-color codes, <A HREF="motion.html#as">as</A> the `rgb_attr` and `cterm_attr` parameters
	respectively. The |<A HREF="#ui-rgb">ui-rgb</A>| option has no effect effect anymore.
	Most external UIs will only need to store and use the `rgb_attr`
	attributes.

	`id` 0 will always be used for the default highlight with colors defined
	by `default_colors_set` and no styles applied.

	Note: `id`:s can be reused if Nvim's internal highlight table is full.
	In this <A HREF="change.html#case">case</A>, Nvim will always issue redraws of screen cells that are
	affected by redefined `id`:s, so UIs <A HREF="diff.html#do">do</A> not need to keep track of this
	themselves.

	`info` is an empty array per default, and will be used by the
	|<A HREF="#ui-hlstate">ui-hlstate</A>| extension explaned below.


							    *<A NAME="ui-event-grid_line"></A><B>ui-event-grid_line</B>*
[&quot;grid_line&quot;, grid, row, col_start, cells]
	Redraw a continous part of a `row` on a `grid`, starting at the column
	`col_start`. `cells` is an array of arrays each with 1 to 3 items:
	`[text(, hl_id, repeat)]` . `text` is the <A HREF="mbyte.html#UTF-8">UTF-8</A> text that should be put in
	a cell, with the highlight `hl_id` defined by a previous `hl_attr_define`
	call.  If `hl_id` is not present the most recently seen `hl_id` in
	the same call should be used (it is always sent for the first
	cell in the event). If `repeat` is present, the cell should be
	repeated `repeat` times (including the first time), otherwise just
	once.

	The right cell of a double-width char will be represented <A HREF="motion.html#as">as</A> the empty
	<A HREF="eval.html#string">string</A>. Double-width chars never use `repeat`.

	If the array of cell changes doesn't reach to the end of the line, the
	rest should remain unchanged. A <A HREF="pattern.html#whitespace">whitespace</A> char, repeated
	enough to cover the remaining line, will be sent when the rest of the
	line should be cleared.

[&quot;grid_clear&quot;, grid]
	Clear a `grid`.

[&quot;grid_destroy&quot;, grid]
	`grid` will not be used anymore and the UI can free any data associated
	with <A HREF="motion.html#it">it</A>.

[&quot;grid_cursor_goto&quot;, grid, row, column]
	Makes `grid` the current grid and `row, column` the cursor position on this
	grid.  This event will be sent at most once in a `redraw` batch and
	indicates the visible cursor position.

[&quot;grid_scroll&quot;, grid, top, bot, left, right, rows, cols]
	Scroll the text in the a region of `grid`. The diagrams below illustrate
	what will happen, depending on the scroll direction. &quot;<A HREF="change.html#=">=</A>&quot; is used to
	represent the SR(scroll region) boundaries and &quot;<A HREF="motion.html#-">-</A>&quot; the moved rectangles.
	Note that dst and src share a common region.

	If `rows` is bigger than 0, move a rectangle in the SR up, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> down.

<B>		+-------------------------+</B>
<B>		| (clipped above SR)      |            ^</B>
<B>		|=========================| dst_top    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		+-------------------------+ src_top    |</B>
<B>		| src (moved up) and dst  |            |</B>
<B>		|-------------------------| dst_bot    |</B>
<B>		| src (cleared)           |            |</B>
<B>		+=========================+ src_bot</B>
 
	If `rows` is <A HREF="various.html#less">less</A> than zero, move a rectangle in the SR down, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> up.

<B>		+=========================+ src_top</B>
<B>		| src (cleared)           |            |</B>
<B>		|------------------------ | dst_top    |</B>
<B>		| src (moved down) and dst|            |</B>
<B>		+-------------------------+ src_bot    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		|=========================| dst_bot    |</B>
<B>		| (clipped below SR)      |            v</B>
<B>		+-------------------------+</B>
 
	`cols` is always zero in this version of Nvim, and reserved for future
	use. 

	Note when updating code from |<A HREF="#ui-grid-old">ui-grid-old</A>| events: ranges are
	end-exclusive, which is consistent with <A HREF="api.html#API">API</A> conventions, but different
	from `set_scroll_region` which was end-inclusive.

==============================================================================

Legacy Grid Events (cell based)					   *<A NAME="ui-grid-old"></A><B>ui-grid-old</B>*

This is an older representation of the screen grid, used if `ext_linegrid`
option is not set. New UIs should use |<A HREF="#ui-linegrid">ui-linegrid</A>|.

[&quot;resize&quot;, width, height]
	The grid is resized to `width` and `height` cells.

[&quot;clear&quot;]
	Clear the grid.

[&quot;eol_clear&quot;]
	Clear from the cursor position to the end of the current line.

[&quot;cursor_goto&quot;, row, col]
	Move the cursor to position (row, col). Currently, the same cursor is
	used to define the position for text insertion and the visible cursor.
	However, only the last cursor position, after processing the entire
	array in the &quot;redraw&quot; event, is intended to be a visible cursor
	position.

[&quot;update_fg&quot;, color]
[&quot;update_bg&quot;, color]
[&quot;update_sp&quot;, color]
	Set the default foreground, background and special colors
	respectively.


							*<A NAME="ui-event-highlight_set"></A><B>ui-event-highlight_set</B>*
[&quot;highlight_set&quot;, attrs]
	Set the attributes that the next text put on the grid will have.
	`attrs` is a <A HREF="eval.html#dict">dict</A> with the keys below. Any absent key is reset
	to its default value. Color defaults are set by the `update_fg` etc
	updates. All <A HREF="options.html#boolean">boolean</A> keys default to false.

	`foreground`:	foreground color.
	`background`:	backround color.
	`special`:	color to use for <A HREF="syntax.html#underline">underline</A> and <A HREF="syntax.html#undercurl">undercurl</A>, when present.
	`reverse`:	reverse video. Foreground and background colors are
			switched.
	`italic`:	<A HREF="syntax.html#italic">italic</A> text.
	`bold`:		<A HREF="syntax.html#bold">bold</A> text.
	`underline`:	underlined text. The line has `special` color.
	`undercurl`:	undercurled text. The curl has `special` color.

[&quot;put&quot;, text]
	The (utf-8 encoded) <A HREF="eval.html#string">string</A> `text` is put at the cursor position
	(and the cursor is advanced), with the highlights <A HREF="motion.html#as">as</A> set by the
	last `highlight_set` update.

[&quot;set_scroll_region&quot;, top, bot, left, right]
	Define the scroll region used by `scroll` below.
	
	Note: ranges are end-inclusive, which is inconsistent with <A HREF="api.html#API">API</A>
	conventions.

[&quot;scroll&quot;, count]
	Scroll the text in the scroll region. The diagrams below illustrate
	what will happen, depending on the scroll direction. &quot;<A HREF="change.html#=">=</A>&quot; is used to
	represent the SR(scroll region) boundaries and &quot;<A HREF="motion.html#-">-</A>&quot; the moved rectangles.
	Note that dst and src share a common region.

	If <A HREF="intro.html#count">count</A> is bigger than 0, move a rectangle in the SR up, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> down.

<B>		+-------------------------+</B>
<B>		| (clipped above SR)      |            ^</B>
<B>		|=========================| dst_top    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		+-------------------------+ src_top    |</B>
<B>		| src (moved up) and dst  |            |</B>
<B>		|-------------------------| dst_bot    |</B>
<B>		| src (cleared)           |            |</B>
<B>		+=========================+ src_bot</B>
 
	If <A HREF="intro.html#count">count</A> is <A HREF="various.html#less">less</A> than zero, move a rectangle in the SR down, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> up.

<B>		+=========================+ src_top</B>
<B>		| src (cleared)           |            |</B>
<B>		|------------------------ | dst_top    |</B>
<B>		| src (moved down) and dst|            |</B>
<B>		+-------------------------+ src_bot    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		|=========================| dst_bot    |</B>
<B>		| (clipped below SR)      |            v</B>
<B>		+-------------------------+</B>
 
==============================================================================

Detailed highlight state Extension 				  *<A NAME="ui-hlstate"></A><B>ui-hlstate</B>*

Only sent if `ext_hlstate` option is set in |<A HREF="#ui-options">ui-options</A>|. `ext_hlstate` implies
`ext_linegrid`.

By default, <A HREF="nvim.html#nvim">nvim</A> will only describe grid cells using the final calculated
higlight attributes, <A HREF="motion.html#as">as</A> described by the <A HREF="eval.html#dict">dict</A> keys in |<A HREF="#ui-event-highlight_set">ui-event-highlight_set</A>|.
The `ext_hlstate` extension allows to the UI to also receive a semantic
describtion of the higlights active in a cell. In this mode highlights will be
predefined in a table, see |<A HREF="#ui-event-hl_attr_define">ui-event-hl_attr_define</A>| and |<A HREF="#ui-event-grid_line">ui-event-grid_line</A>|.
The `info` parameter in `hl_attr_define` will contain a semantic description
of the highlights. As highlight groups can be combined, this will be an array
of items, with the item with highest priority last. Each item is a dictionary
with the following possible keys:

    `kind`:	always present. One of the following values:
	&quot;<A HREF="#ui">ui</A>&quot;:       A builtin <A HREF="#ui">ui</A> highlight.
	&quot;<A HREF="syntax.html#syntax">syntax</A>&quot;:   highlight applied to a buffer by a <A HREF="syntax.html#syntax">syntax</A> declaration or
	            other runtime/plugin functionallity such <A HREF="motion.html#as">as</A>
		    |<A HREF="api.html#nvim_buf_add_highlight()">nvim_buf_add_highlight()</A>|
	&quot;terminal&quot;: highlight from a process running in a |<A HREF="nvim_terminal_emulator.html#terminal-emulator">terminal-emulator</A>|.
		    Contains no futher semantic information.
    `ui_name`:	Name of the builtin highlight. See |<A HREF="syntax.html#highlight-groups">highlight-groups</A>| for
	        possible values. Only present for &quot;<A HREF="#ui">ui</A>&quot;.
    `hi_name`:	Name of the final |<A HREF="syntax.html#:highlight">:highlight</A>| group where the used
		attributes are defined.
    `id`:	Unique numeric id representing this item.

Note: &quot;<A HREF="#ui">ui</A>&quot; items will have both `ui_name` and `hi_name` present. These can
differ, because the builtin group was linked to another group |<A HREF="syntax.html#:hi-link">:hi-link</A>| , or
because <A HREF="options.html#'winhighlight'">'winhighlight'</A> was used. UI items will be transmitted, even if the
highlight group is cleared, so `ui_name` can always be used to reliably identify
screen elements, even if no attributes have been applied.

==============================================================================

Popupmenu Events						 *<A NAME="ui-popupmenu"></A><B>ui-popupmenu</B>*

Only sent if `ext_popupmenu` option is set in |<A HREF="#ui-options">ui-options</A>|

[&quot;popupmenu_show&quot;, items, selected, row, col]
	Show |<A HREF="insert.html#popupmenu-completion">popupmenu-completion</A>|. `items` is an array of completion items
	to show; each item is an array of the form [word, kind, menu, info] <A HREF="motion.html#as">as</A>
	defined at |<A HREF="insert.html#complete-items">complete-items</A>|, except that `word` is replaced by `abbr`
	if present.  `selected` is the initially-selected item, a zero-based
	index into the array of items (-1 if no item is selected). `row` and
	`col` give the anchor position, where the first character of the
	completed <A HREF="motion.html#word">word</A> will be.

[&quot;popupmenu_select&quot;, selected]
	<A HREF="visual.html#Select">Select</A> an item in the current popupmenu. `selected` is a zero-based
	index into the array of items from the last popupmenu_show event, or
	-1 if no item is selected.

[&quot;popupmenu_hide&quot;]
	Hide the popupmenu.

==============================================================================

Tabline Events							   *<A NAME="ui-tabline"></A><B>ui-tabline</B>*

Only sent if `ext_tabline` option is set in |<A HREF="#ui-options">ui-options</A>|

[&quot;tabline_update&quot;, curtab, tabs]
	Tabline was updated. UIs should present this data in a custom tabline
	widget.
	curtab:	  Current Tabpage
	tabs:	  <A HREF="eval.html#List">List</A> of Dicts <A HREF="motion.html#[{">[{</A> &quot;<A HREF="intro.html#tab">tab</A>&quot;: Tabpage, &quot;name&quot;: <A HREF="eval.html#String">String</A> }, ...]

==============================================================================

<A HREF="cmdline.html#Cmdline">Cmdline</A> Events							   *<A NAME="ui-cmdline"></A><B>ui-cmdline</B>*

Only sent if `ext_cmdline` option is set in |<A HREF="#ui-options">ui-options</A>|

[&quot;cmdline_show&quot;, content, pos, firstc, prompt, indent, level]
        content: <A HREF="eval.html#List">List</A> of [attrs, string]
	         [[{}, &quot;t&quot;], [attrs, &quot;est&quot;], ...]

	Triggered when the <A HREF="cmdline.html#cmdline">cmdline</A> is displayed or changed.
	The `content` is the full content that should be displayed in the
	<A HREF="cmdline.html#cmdline">cmdline</A>, and the `pos` is the position of the cursor that in the
	<A HREF="cmdline.html#cmdline">cmdline</A>. The content is divided into chunks with different highlight
	attributes represented <A HREF="motion.html#as">as</A> a <A HREF="eval.html#dict">dict</A> (see |<A HREF="#ui-event-highlight_set">ui-event-highlight_set</A>|).

	`firstc` and `prompt` are text, that if non-empty should be
	displayed in front of the command line. `firstc` always indicates
	built-in command lines such <A HREF="motion.html#as">as</A> `:` (ex command) and `/` `?` (search),
	while `prompt` is an |<A HREF="eval.html#input()">input()</A>| prompt. `indent` tells how many spaces
	the content should be indented.

	The Nvim command line can be invoked recursively, for instance by
	typing `&lt;c-r&gt;=` at the command line prompt. The `level` field is used
	to distinguish different command lines active at the same time. The
	first invoked command line has level 1, the next recursively-invoked
	prompt has level 2. A command line invoked from the |<A HREF="cmdline.html#cmdline-window">cmdline-window</A>|
	has a higher level than than the edited command line.

[&quot;cmdline_pos&quot;, pos, level]
	Change the cursor position in the <A HREF="cmdline.html#cmdline">cmdline</A>.

[&quot;cmdline_special_char&quot;, <A HREF="change.html#c">c</A>, <A HREF="intro.html#shift">shift</A>, level]
	Display a special char in the <A HREF="cmdline.html#cmdline">cmdline</A> at the cursor position. This is
	typically used to indicate a pending state, e.g. after |<A HREF="cmdline.html#c_CTRL-V">c_CTRL-V</A>|. If
	`shift` is true the text after the cursor should be shifted, otherwise
	<A HREF="motion.html#it">it</A> should overwrite the char at the cursor.

	Should be hidden at next cmdline_show.

[&quot;cmdline_hide&quot;]
	Hide the <A HREF="cmdline.html#cmdline">cmdline</A>.

[&quot;cmdline_block_show&quot;, lines]
	Show a block of context to the current command line. For example if
	the user defines a |<A HREF="eval.html#:function">:function</A>| interactively:
<B>	    :function Foo()</B>
<B>	    :  echo "foo"</B>
<B>	    :</B>
 
	`lines` is a <A HREF="eval.html#list">list</A> of lines of highlighted chunks, in the same form <A HREF="motion.html#as">as</A>
	the &quot;cmdline_show&quot; `contents` parameter.

[&quot;cmdline_block_append&quot;, line]
	Append a line at the end of the currently shown block.

[&quot;cmdline_block_hide&quot;]
	Hide the block.

==============================================================================

Wildmenu Events							   *<A NAME="ui-wildmenu"></A><B>ui-wildmenu</B>*

Only sent if `ext_wildmenu` option is set in |<A HREF="#ui-options">ui-options</A>|

[&quot;wildmenu_show&quot;, items]
	Activate the wildmenu (command-line completion). `items` is an array
	with the completion items.

[&quot;wildmenu_select&quot;, selected]
	<A HREF="visual.html#Select">Select</A> an item in the current wildmenu. `selected` is a zero-based
	index into the array of items from the last wildmenu_show event, or -1
	if no item is selected.

[&quot;wildmenu_hide&quot;]
	Hide the wildmenu.

==============================================================================
<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>
  </body>
</html>
